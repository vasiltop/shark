use std::{
    fs::File,
    io::{self, Stdout, Write},
};

use clap::Parser;
use crossterm::{
    cursor,
    event::{read, Event, KeyCode, KeyEventKind},
    execute, queue,
    style::Print,
    terminal,
};
use ropey::Rope;

#[derive(Parser, Debug)]
struct Args {
    filename: String,
}

struct Editor {
    text: Rope,
    stdout: Stdout,
}

impl Editor {
    fn new(stdout: Stdout, text: Rope) -> Self {
        Self { stdout, text }
    }

    fn update_display(&self, stdout: &mut Stdout, rope: Rope) -> std::io::Result<()> {
        execute!(
            stdout,
            terminal::Clear(terminal::ClearType::All),
            cursor::MoveTo(0, 0)
        )?;

        for line in rope.lines() {
            queue!(stdout, Print(line))?;
        }

        stdout.flush()?;

        Ok(())
    }
}

fn main() -> std::io::Result<()> {
    let mut stdout = io::stdout();

    let args = Args::parse();

    let text = Rope::from_reader(File::open(args.filename)?)?;

    execute!(stdout, terminal::EnterAlternateScreen)?;
    terminal::enable_raw_mode()?;

    let editor = Editor::new(stdout, text);

    editor.update_display(&mut stdout, text)?;

    loop {
        let event = read()?;

        match event {
            Event::Key(event) if event.kind == KeyEventKind::Press => {
                if event.code == KeyCode::Esc {
                    break;
                }
            }
            _ => {}
        }
    }

    execute!(stdout, terminal::LeaveAlternateScreen)?;
    terminal::disable_raw_mode()?;
    Ok(())
}
